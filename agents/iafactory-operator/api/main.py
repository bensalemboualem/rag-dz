"""
IA Factory Operator - FastAPI Application
Main API endpoints for video editing service
"""

import os
import tempfile
from datetime import datetime
from typing import Optional
from contextlib import asynccontextmanager

import structlog
from fastapi import FastAPI, HTTPException, BackgroundTasks, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from core.config import settings
from core.models import (
    VideoEditRequest,
    VideoJobResponse,
    JobListResponse,
    JobStatusEnum,
    VideoOutput,
    WebhookPayload,
    TemplateInfo,
    PlatformInfo,
    PlatformEnum,
    TemplateEnum,
)
from core.state import VideoEditorState, PLATFORM_SPECS, TEMPLATE_CONFIGS
from services import (
    get_queue_service,
    get_storage_client,
    get_llm_client,
    get_whisper_client,
)
from worker.tasks import process_video_job

logger = structlog.get_logger(__name__)


# =============================================================================
# LIFESPAN
# =============================================================================

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan handler"""
    logger.info("Starting IA Factory Operator...")
    
    # Initialize services
    yield
    
    logger.info("Shutting down IA Factory Operator...")


# =============================================================================
# APP INITIALIZATION
# =============================================================================

app = FastAPI(
    title="IA Factory Video Operator",
    description="API de montage vidÃ©o automatique pour les rÃ©seaux sociaux",
    version="1.0.0",
    docs_url="/operator/docs",
    redoc_url="/operator/redoc",
    openapi_url="/operator/openapi.json",
    lifespan=lifespan,
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# =============================================================================
# HEALTH CHECK
# =============================================================================

@app.get("/operator/health")
async def health_check():
    """Health check endpoint"""
    queue = get_queue_service()
    stats = queue.get_queue_stats()
    
    return {
        "status": "healthy",
        "service": "iafactory-video-operator",
        "version": "1.0.0",
        "environment": settings.environment,
        "queue": stats,
        "timestamp": datetime.utcnow().isoformat(),
    }


# =============================================================================
# VIDEO JOBS
# =============================================================================

@app.post(
    "/operator/video/jobs",
    response_model=VideoJobResponse,
    status_code=201,
    summary="Create video editing job",
    description="Submit a new video for automated editing"
)
async def create_video_job(
    request: VideoEditRequest,
    background_tasks: BackgroundTasks,
):
    """
    Create a new video editing job.
    
    The video will be processed asynchronously:
    1. Downloaded from source URL
    2. Analyzed for scenes and content
    3. Edit plan generated by AI
    4. Rendered for target platforms
    5. Uploaded to storage
    
    Returns job ID for status tracking.
    """
    # Generate job ID
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    job_id = f"opv_{timestamp}_{os.urandom(4).hex()}"
    
    logger.info(f"Creating job: {job_id}", request=request.dict())
    
    # Create initial state
    state = VideoEditorState.from_request(job_id, request)
    state.created_at = datetime.utcnow()
    
    # Enqueue job
    queue = get_queue_service()
    queue.enqueue_job(
        process_video_job,
        state.to_dict(),
        job_id=job_id,
    )
    
    # Store initial state
    queue.store_result(job_id, {
        "job_id": job_id,
        "status": JobStatusEnum.pending.value,
        "progress": 0,
        "created_at": state.created_at.isoformat(),
        "input": request.dict(),
    })
    
    # Build response
    response = VideoJobResponse(
        job_id=job_id,
        status=JobStatusEnum.pending,
        progress=0,
        created_at=state.created_at,
        updated_at=state.created_at,
        input=request,
        outputs=[],
    )
    
    return response


@app.get(
    "/operator/video/jobs/{job_id}",
    response_model=VideoJobResponse,
    summary="Get job status",
    description="Get the current status and results of a video editing job"
)
async def get_video_job(job_id: str):
    """
    Get job status and results.
    
    Returns current progress, outputs (if completed), and any errors.
    """
    queue = get_queue_service()
    
    # Get stored result
    result = queue.get_result(job_id)
    
    if not result:
        # Try RQ job
        job_status = queue.get_job_status(job_id)
        if job_status["status"] == "not_found":
            raise HTTPException(status_code=404, detail="Job not found")
        result = job_status
    
    # Get progress
    progress_data = queue.get_job_status(job_id)
    
    # Build response
    try:
        response = VideoJobResponse(
            job_id=job_id,
            status=JobStatusEnum(result.get("status", "pending")),
            progress=progress_data.get("progress", result.get("progress", 0)),
            created_at=datetime.fromisoformat(result["created_at"]) if result.get("created_at") else datetime.utcnow(),
            updated_at=datetime.fromisoformat(result.get("updated_at", result.get("created_at", datetime.utcnow().isoformat()))),
            started_at=datetime.fromisoformat(result["started_at"]) if result.get("started_at") else None,
            completed_at=datetime.fromisoformat(result["completed_at"]) if result.get("completed_at") else None,
            input=VideoEditRequest(**result["input"]) if result.get("input") else None,
            outputs=[VideoOutput(**o) for o in result.get("outputs", [])],
            transcript=result.get("transcript"),
            scenes_detected=result.get("scenes_detected", 0),
            logs=result.get("logs", []),
            error=result.get("error"),
        )
        return response
    except Exception as e:
        logger.error(f"Error building response: {e}", result=result)
        raise HTTPException(status_code=500, detail=str(e))


@app.delete(
    "/operator/video/jobs/{job_id}",
    summary="Cancel job",
    description="Cancel a pending or running job"
)
async def cancel_video_job(job_id: str):
    """Cancel a job if it's still pending"""
    queue = get_queue_service()
    
    if queue.cancel_job(job_id):
        return {"message": "Job cancelled", "job_id": job_id}
    else:
        raise HTTPException(
            status_code=400,
            detail="Cannot cancel job - may already be running or completed"
        )


@app.get(
    "/operator/video/jobs",
    response_model=JobListResponse,
    summary="List jobs",
    description="List video editing jobs with pagination"
)
async def list_video_jobs(
    page: int = Query(1, ge=1),
    per_page: int = Query(20, ge=1, le=100),
    status: Optional[JobStatusEnum] = None,
):
    """List jobs with optional status filter"""
    # This would need a proper database in production
    # For now, return empty list
    return JobListResponse(
        jobs=[],
        total=0,
        page=page,
        per_page=per_page,
        has_more=False,
    )


# =============================================================================
# TEMPLATES & PLATFORMS
# =============================================================================

@app.get(
    "/operator/templates",
    response_model=list[TemplateInfo],
    summary="List templates",
    description="Get available editing templates"
)
async def list_templates():
    """Get all available editing templates"""
    templates = []
    
    for template_id, config in TEMPLATE_CONFIGS.items():
        templates.append(TemplateInfo(
            id=TemplateEnum(template_id),
            name=config["name_fr"],
            name_ar=config["name_ar"],
            name_en=config["name_en"],
            description=f"Template {config['name_en']}",
            icon="ðŸŽ¬",
            recommended_duration=15,
        ))
    
    return templates


@app.get(
    "/operator/platforms",
    response_model=list[PlatformInfo],
    summary="List platforms",
    description="Get supported output platforms and their specs"
)
async def list_platforms():
    """Get all supported platforms"""
    platforms = []
    
    for platform_id, specs in PLATFORM_SPECS.items():
        platforms.append(PlatformInfo(
            id=PlatformEnum(platform_id),
            name=platform_id.replace("_", " ").title(),
            aspect_ratio=specs["aspect_ratio"],
            width=specs["width"],
            height=specs["height"],
            max_duration=specs["max_duration"],
            recommended_duration=specs["recommended_duration"],
        ))
    
    return platforms


# =============================================================================
# QUEUE STATS
# =============================================================================

@app.get("/operator/stats")
async def get_stats():
    """Get queue and processing statistics"""
    queue = get_queue_service()
    return {
        "queue": queue.get_queue_stats(),
        "timestamp": datetime.utcnow().isoformat(),
    }


# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    logger.exception("Unhandled exception", error=str(exc))
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "detail": str(exc) if settings.environment == "development" else None,
        }
    )


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    import uvicorn
    
    uvicorn.run(
        "api.main:app",
        host="0.0.0.0",
        port=8085,
        reload=settings.environment == "development",
        workers=1,
    )
